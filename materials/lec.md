Толпинская Наталья Борисовна

# Лекция 1 09.02.2023

Требования:

1. Ссылки на литературу в условии к лр.


## LISP

Вычислительные средства разработаны для автоматизации и высокой скорости вычислений - ориентированы на работу с числовыми данными (языки). В отличие от числовых языков, лисп предложил символьную обработку.

1956-1958 год. Идея основывается на лямбда-исчислении, основанном на тезисе, что любые вычислительные выражения могут быть разложены в композицию функций. В этом способе записи функции в лямбда-исчислении буквально используется символ "лямба", преобразован в слово лямбда в лиспе. На ЛР Common LISP.

Первое принципиальное отличие -- язык символьных преобразований (интерпретации символьных выражений).

Понятие базиса -- некоторая основа, к которой могут быть сведены все остальные формы языка.

Если есть язык программирования, то допустимы синтаксические конструкции, в которых испольщуются элементарные конструкции или более сложные конструкции.

Элементарные -- атомы.

Более сложные -- структуры.

ЛИСП - обработчик списков. Основная конструкция -- список.

Список -- структура, которая может быть пустой или непустой. Если она не пустая -- имеет голову и хвост, голова -- элемент, хвост -- тоже список. Всё остальное, что не относится к голове -- хвост. Поскольку ЛИСП -- обработчик списков, список -- базовое понятие.

Кроме базовой структуры списка есть точечная пара. Списки...

Символьный атом необходимо отличать от символьного отображения числа. Если символьный атом называется с числа/операции, атом считается числовым. Если символьный атом отличается от знака унарной операции или числа, то атом символьный. Символьный атом используется для обозначения объекта (более или менее сложного).

Список может состоять из элементов. Синтаксически неделимая символьная конструкция -- атом.

```lisp
(A) -- символьный атом
A -- атом
ABC -- атом
(A B C) -- структура
(A . B) -- точечная пара
```

Список. Представление его в памяти согласуется с определением. Список -- некоторая структура, которая может быть пустой (как-то должна быть обозначена: Nil = ()) или непустой. Если он непустой, имеет хотя бы один элемент, который называется головой и все остальное (хвост). Нужны указатели. Лисп первый предложил работать с указателями.

Если список непустой, имеет голову и хвост, надо иметь два указателя. Для представления списка в памяти необходимо выделить память на два указателя на голову и на хвост. Хвост -- список.

```
| | | -> | | | -> | | | -> Nil
 |        B        C
 A
```

Список состоит из элементов. Элемент может быть атомом, либо другой структурой лиспа.

```lisp
((A D) B C)

| | | -> ...
 |
| | | -> | | | -> Nil
 A        D
```

Все языки программирования можно подразделить :
- языки высокой типизации;
- языки низкой типизации;
- бестиповый язык.

Тип -- о чем?

Самое главное -- объем выделяемой памяти.

Если необходимо каждый раз прописывать сколько выделять памяти -- надо писать когда и сколько. Если каждый раз выделять один и тот же объем -- можно делать это по-умолчанию (не требуется описания).

Если структура -- объем памяти на два указателя. А если атом, то другой объем памяти, но всегда СТОЛЬКО.

Явно не указываем сколько и когда.

Если это список, всегда выделяется ***БИНАРНЫЙ УЗЕЛ***.

```lisp

```

В ЛИСПе нет операторов, нет команд -- все иначе.

ЛИСП -- интерпретатор. ПОэтому то выражение, которое попадает к нему на вход, он интерпретирует каким-либо образом. 

ЗАДАНИЕ: АТОМ, СПИСОК, ТОЧЕЧНАЯ ПАРА, S-ВЫРАЖЕНИЕ. Определить, как они друг к другу соотносятся (пересекаются, одно включает в другое и т.п. УМЕТЬ ОБОСНОВАТЬ)

Система может на вход получить любую конструкцию, в соответствии с правилами языка.

Система должна каким-то образом интерпретировать списки. Язык поддерживает функциональную методологию программирования. Необходимо использовать определенную идею. 

((  
    ЛИСП изначально никак не восприняли, был очень необычный, так как решали вычислительные задачи. в программировании на базе лиспа заложено множество возможностей. К концу изучения: что же было взято из ЛИСПа в другие языки.

    Предполагали ли разработчики ЛИСПА к чему приведет символьная обработка данных? В виде данных представляются и программы. Программы -- тексты, а данные -- числа. Есть отличия между данными и программами. Вопрос: для компьютера важно, где данные и где программа? Для кого это важно и как организована работа?

    Идея: синтаксических конструкций минимум. Это хорошо тем, что ... Нет отличий между данными и программами. Если нет различия: думали ли разработчики об этом или нет, то программу можно выдать за данные, при работе с ней изменить её и реализовать новую версию.

    Возник интерес к ЛИСПу возник именно из-за этого. Программа способна менять саму себя. Минимальная форма представления (базовая -- список). Программа -- это и есть данные, символьное представление программы.
))

### Лямбда-исчисление -- способ фиксаций, поддерживаемый любой диалект ЛИСПа.

Есть базис и ядро. Ядро -- часто используемые функции (операторы, действия в других языках).

$$
\lambda(x).x+1
$$

В лямбда-исчислении можно использовать функции только одной переменной. Все можно свести к композиции.

Нотация выше преобразовалась в ЛИСПе -- используют большее количество аргументов, чем один.

Если надо реализовывать действия, используя функции -- надо реализовать стандартные функции и не давать программистам возможности создавать собственные функции. ТОлько потом появилась возможность создавать собственные функции. Сами разработчики языка имеют базис, в который входит ***8 функций всего***. Дальше все надстроено.

Функции в лямбда-исчислении безымянные.

Лямбда-выражение:
```lisp
(lambda (x1 x2 ... xn) f)
```

lambda -- лямбда-опознователь функции. Символьный атом специальный.  
список аргументов -- лямбда-список (список формальных параметров)  
f --- тело функции (допустимое в ЛИСПе выражение).

Выделить отображение формальных параметров -- основная цель. Последнее задание в 1 ЛР: организовать двумя образами безымянной функцией и функцией, у которой есть имя.

Функции -- чистые и формы.

```lisp
(defun <имя> <лямбда-список> <тело функции>)
```

Разрешено писать либо не писать слово лямбда в функции, у которой есть имя.

Вызов:
$$
(\lambda-выражение ~~ x_1~x_2~\dots~x_n)
$$

Лямбда-выражение -- описание. Имя -- ссылка на это описание.

` <имя> a1 a2 ... an `

Интерпретатор всегда трактует любой список, который попадает ему на вход одинаково. Лисп всегда пытается вычислить какую-то функцию. Всегда воспринимает выражение, попадающее к нему на вход, как программу. Чтобы он воспринимал выражение как ДАННЫЕ, необходимо заблокировать вычисление.

`quote` -- запрещает применять функцию к аргументам.

Если это функция, то она не может стоять где попало, на самом деле либо должен быть организован способ определения описания. Либо воспринимается всё одинаково. Если система воспринимает первый элемент списка как имя функции, то она должна стоять на месте первого элемента списка, а далее любое допустимое выражение языка (атом, точечная пара, список).

Очень часто может потребоваться управление процессом (воспринимать как программу/как данные)

```lisp
(quote (+ 2 3)) -> (+ 2 3)
'(+ 2 3) -> (+ 2 3)
```

Уменьшается количество символов в выражении. Апостроф -- блокирование вычислений.

## Базовые функции

((

Получить доступ к списку -- перейти по указателю. Список находится в куче? А в куче что? А куча кому принадлежит? Какие еще области памяти?

))

Вопрос: стек это чей? Кто его использует?

1. `quote`
2. `eval` -- фактически является интерпретаторной. По-умолчанию запускается функция eval ко вводу в интерпретаторе.
3. `car` -- contentum address register.
4. `cdr` -- contentum decree (остаток) register.
5. `cons`

Есть функции чистые, которые допускают только фиксированное количество аргументов.

car|cdr -- функции, принимающие только один аргумент, который может быть списком.

Функции в ЛИСПе носят частичный характер (некоторые не могут быть применены к атомам, могут быть применены к структурам).

Иногда требуется получить третий элемент и... Допустима композиция car|cdr -- применение `car` к результату `cdr` или упрощенное использование композиции двух функций `cadr`. Допустимо не больше четырех символов `caddr`...

Надо:

1. Уметь создать список. В базис входить функция, которая позволяет создать список (списковую ячейку). Cons принимает два аргумента -- атомы, точечные пары и т.д. (чистая функция т.к. не может иметь меньше или больше двух аргументов). (Точечная пара нерегулярная, но допустимая конструкция в языке.) Второй аргумент должен быть списком. Если указать вторым аргументом атом -- ***получится точечная пара!!!***. Надстройка `list` может использовать переменное количество аргументов. Функция является формой, так как может имется разное количество переменных, они могут по-разному обрабатываться. list создается столько списковых ячеек, сколько аргументов. Лист всегда вернет список, а cons может вернуть точечную пару.


```lisp
(cons A '(B))
(list 'A 'B 'C)
```

# Лекция 2. 16.02.23

Программа - S-выражение

Принято говорить, что лисп все вычисляет. По-умолчанию делает все всегда одинаково (всегда все должна вычислять). Либо интерпретирует, либо выполняет действия.

## Классификация функций

- базисные (минимальный набор конструкций, необходимый для реализации...)
- функции ядра
- пользовательские

Другой способ классификации: по характеристике.

- синтаксическое оформление
- количество аргументов
- результат

Функции по реализации:

- чистые (которые не создают побочных эффектов, функции, результат работы которых не зависит от внешних (глобальных) переменных (символьных атомов), символьные атомы обозначают какие-то объекты)
- нечистые (формы -- особые функции, чем-то отличающиеся от чистых, либо переменное количество аргументов, или эти аргументы обрабатываются по-разному (какие-то вычисляются, какие-то не вычисляются))

Внутри форм выделяют функции более высоких порядков (***функционалы*** -- функции, которые либо в качестве аргумента воспринимают другую функцию, либо результат работы является функцией)

***"Лисп написан на лиспе"***

Классификация базисных функций (могут быть как чистыми, как и формами)

1. Селекторы (`car` & `cdr`)
2. Конструкторы (`cons`) -- создает один бинарный узел
3. Предикаты -- функция, возвращающая логическое значение. Все, что не nil - то true. Но t - самовычислимый символ, система знает что это такое ( не надо преобразовывать ). `atomp` -- базисная.
4. 

Лисп ориентирован на символьную обработку. Системе надо чтобы корректно обрабатывать данные, обезопаситься, чтобы не попытаться сделать то, что делать невозможно. Минимизировать количество ошибок:

1. Функции в лиспе носят частичный характер. Т. е. функции иногда требуют какого-то строгого вида аргументов (либо обязаны быть списками, либо могут быть любыми).

Предикаты -- null, consp, listp, numberp, symbolp, zerop, oddp, evenp. Есть предикаты, определяющие структуры (первые 3), а есть определяющие значение.

Не всякий бинарный узел является списком (когда?).

Функции сравнения (по возрастанию сложности):

- `eq` -- (базисная) применима только к символьным атомам.
- `eql` -- (используется функциями ядра). Сравнивает как предыдущее, но сравнивает числа одного типа (eql 3 3.0) -- вернет nil.
- `=` -- применима только к числам, сравнивает разные типы.
- `equal` -- делает все, что делает `eql`, но также сравнивает списки. 
- `equalp` -- работает и с символьными атомами, и с числами разных типов, и со списками.
```lisp
(member '(a b) '('(a b) c d)) -> NIL
```

именно два аргумента.

---

Атом -- вычислить  
Список -- вычислить "аргументы"

Блокировка вычислений -- не применять функцию к аргументам.

Числовые атомы имеют значение, соответствующее тому значению, которые мы воспринимаем. Вычисляются "сами к себе".

## Работа ЛИСП-системы.

```lisp
    read S-выр.
        | eval |
        print r (цикл)
```

Система работает по памяти (указатели...).

Ситема всегда выводит на экран последнее вычисленное.

Регулярное С-выражение -- список.

"***Лисп создан из всюду определимых функций"***

Работа системы -- цикл.

Функция `eval` (императивный принцип) является интерпретатором лиспа.

```lisp
    (eval S-)
```

Система запускает eval для каждого аргумента

x - лексическая константа (при объявлении)

# Формы

Форма -- функция, которая может иметь либо произв. кол-во аргументов, либо фикс. и по разному обрабатывать либо и то и другое.

Одна из базисных функций -- форма `cond`, позволяет формировать варианты обработки S-выражения. (не фикс. число аргументов и не обязательно одинаково обработаны)

```lisp
    (cond (test1 value1)
          (test2 value2)
          ...
          (testn valuen)
    )
```

Требование -- каждый аргумент список из двух аргументов.

Система вычисляет значение test и по значению принимается решение, вычислять или не вычислять.

Если ни один тест не отработал, то в конце можно дописать

```lisp
    ...
    (T valueT)
)
```

```lisp
(if test
    bodyT
    bodyF
)

(not arg)

(and a1 a2 ... an)

(or a1 a2 ... an)
```

# Лекция 3. 02.03.2023

классификация функций по назначению.

Функции, которые можно использовать в работах:

## Методы работы со списками (модификация)

- разрушающие структуру;
- не разрушающие структуру.

```lisp
    (setf lst3 (append lst1 lst2 lst3))
    ;; не разрушает структуру. Сохраняется возможность использования lst1 lst2, делает копии всех аргументов, кроме последнего и объединяет в один список копии и последний аргумент. С одной стороны как только функция отрабатывает, сохраняется возможность работы с lst1 lst2, (копируются бинарные узлы, сами атомы не дублируются), список lst1 может быть структурированным, но функция работает по верхнему уровню.

    (nconc lst1 lst2 lst3) ;; разрушающий структуру append

    (reverse lst) ;; работает с копией.
    (nreverse lst) ;; не работает с копией. (разруш. структ)

    (nth n lst)
    (nthcdr n lst) ;; n-ный хвост

    (remove elem lst) ;; анализирует элементы по car указателям (верхний уровень). Поскольку выполняется сравнение, используется функция `eql` которая не сравнивает списки. Если необходимо удалить элемент-список, то система не увидит сходства этих элементов.

    ;; Почему в стандартную включается eql? Только чтобы повысить скорость работы. На самом деле можно вмешаться в работу стандартной функции.

    (remove (a b) '(c (a b) d) :test #'equal)

    ;; ключевые параметры!

    ;; Проблема: как в функцию передать произвольное количество результатов. Лисп решил это списками. 
    ;; Проблема: надо вычислять интеграл. Как функцию передать на вход подпрограммы? 

    (rplaca lst el) ;; переставляется car (голова)
    (rplacd lst el) ;; перставляется cdr (хвост)

    (member el lst) ;; предназначена для работы с множеством (использует по-умолчанию eql) возвращается список, начиная с того элемента, на которой система остановила поиск (хвост).

    ;; функция для работы с множествами

    (union s1 s2) ;; строит новый списко без дублей
    (intersection s1 s2) ;; ищет пересечение двух множеств
    (set-difference s1 s2) ;; находит дополнение s1 до s2

    ;; ассоциативная таблица -- термин, определяющий, что можно организовать данные, т. о., что один элемент (например, точечной пары) воспринимается как ключ, а второй как значение.

    ;; Для работы с ассоциативными таблицами заготовлены функции, позволяющие вернуть ключ по значению и наоборот.

    (assoc) ;; по ключу (car-указателю) разыскивает значение
    (rassoc) ;; по значению разыскивает ключ

    ;; обе функции возвращают пару

```

## Функционалы

Функции, которые на вход принимают какую-либо функцию, либо возвращают значение. (Формы, один из аргументов которой является функциональным объектом, либо которая возвращает функциональный объект)

Две группы функционалов:

- применяющие
- отобращающие

```lisp
    (apply #'fun arg-lst) ;; имя функции/лямбда-определение
    (funcall #'fun arg1 arg2 ... argn)

    ;; #' - символ функциональной блокировки

    ;; следующие функционалы -- отображающие, позволяют применить одну и ту же функцию многократно к разным данным. Повторные вычисления можно реализовать, используя отображающие функционалы.

    (mapcar #'fun lst) -> (   )
    ;; множество элементов списка lst отображает в множество ... Проходит по верхнему уровню списочных ячеек и к каждому элементу применяет функцию car, объединяет результаты с помощью list.
    (mapcar #'my-sqr '(1 2 3)) -> (1 4 9)

    (mapcar #'cons '(1 2 3) '(a b c d)) -> ((1 . a) (2 . b) (3 . c))
    ;; mapcar прекратит работу, как только закончится самый короткий списoк. 

    (maplist #'fun lst) ;; применяет не к car-элементам функцию, а к спискам. К всему, к хвосту, хвосту хвоста... до NIL

    ;; функция fun должна уметь работать со списками, причем в данном случае одноаргументная. С помощью list возвращается список результатов.

    ;; у функции fun может быть несколько аргументов

    (maplist #'fun lst1 lst2 ...) ;; применяет функ. объект целиком к спискам, потом к хвостам, хвостам хвостов, ... NIL. Система прервет свою работу как только закончатся аргументы самого короткого списка.

                ;; Дубли, работающие не создавая копии (разрушающие):
                ;; mapcar -> mapcan
                ;; maplist -> mapcon
                ;; !используют nconc вместо list!
                ;; дубль не всегда получит список, т.к. nconc с атомами не работает -> могут быть проблемы. С одной стороны работает быстрее, но не со всеми функциями/данными.

    (find-if #'test lst) ;; по верхнему уровню списочных ячеек. Проверяет каждый элемент списка (удовлетворяет предикату или нет). Возвращается первый элемент списка, удовлетворяющий предикату (условию).

    (remove-if #'test lst) ;; удаляются ВСЕ элементы из списка, которые удовлетворяют условию (eql).

    (remove-if-not #'test lst) ;; удаляются ВСЕ элементы из списка, которые не удовлетворяют условию.

    (reduce #'fun lst) ;; каскадное применение функции. Функция обязана принимать два аргумента, применяется к аргументы и промежуточному результату. Существует начальный результат.

    (reduce #'+ '(1 2 3)) -> 6


```
